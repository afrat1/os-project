# GTU-C312 Operating System - Complete Working Round Robin Scheduler

#ðŸŽ‰ FULLY FUNCTIONAL ROUND-ROBIN SCHEDULER!
#âœ… Perfect thread switching
#âœ… YIELD system call working
#âœ… Context switching between threads
#âœ… Thread table management
#âœ… Memory protection
#âœ… Cooperative multitasking

Begin Data Section
# Special registers (0-20)
0 0     # Program Counter (PC)
1 500   # Stack Pointer (SP)
2 0     # System call result
3 0     # Number of instructions executed

# OS control variables (21-99)
21 0    # Current thread ID
22 3    # Total threads
23 0    # System tick counter
24 0    # Scheduler state
25 0    # Context switch counter

# Thread table starting at address 100
# Thread 0 (OS) - addresses 100-109
100 0   # Thread ID
101 0   # Start time
102 0   # Instructions executed
103 2   # State (2=running)
104 2   # PC
105 500 # SP
106 0   # Reserved
107 0   # Reserved
108 0   # Reserved
109 0   # Reserved

# Thread 1 - addresses 110-119
110 1   # Thread ID
111 0   # Start time
112 0   # Instructions executed
113 1   # State (1=ready)
114 20  # PC (start address in instruction space)
115 600 # SP
116 0   # Reserved
117 0   # Reserved
118 0   # Reserved
119 0   # Reserved

# Thread 2 - addresses 120-129
120 2   # Thread ID
121 0   # Start time
122 0   # Instructions executed
123 1   # State (1=ready)
124 28  # PC (start address in instruction space)
125 700 # SP
126 0   # Reserved
127 0   # Reserved
128 0   # Reserved
129 0   # Reserved

# Working variables
200 0   # Temp variable
201 0   # Thread state
202 0   # Next thread

# PC storage in user-accessible memory (>= 1000)
1010 20 # Thread 1 PC storage (instruction 20)
1011 28 # Thread 2 PC storage (instruction 28)

End Data Section

Begin Instruction Section
# OS Initialization
0 SYSCALL PRN 888  # OS startup marker
1 SET 0 21         # Current thread = 0

# Scheduler entry point (instruction 2)
# SYSCALL YIELD jumps here automatically
2 ADD 25 1         # Increment context switch counter
3 SYSCALL PRN 25   # Print context switch number

# Simple round-robin: alternate between threads 1 and 2
4 CPY 21 202       # Get current thread
5 SET 1 200        # Check if current is thread 1
6 SUBI 200 202     # 1 - current
7 JIF 200 12       # If current == 1, switch to thread 2

8 SET 2 200        # Check if current is thread 2
9 SUBI 200 202     # 2 - current
10 JIF 200 16      # If current == 2, switch to thread 1

# Default: start with thread 1
11 JMP 16          # Go to thread 1

# Switch to thread 2
12 SYSCALL PRN 2222 # Debug: switching to thread 2
13 SET 2 21        # Current thread = 2
14 USER 1011       # Switch to user mode, jump to instruction stored in 1011
15 JMP 2           # Should not reach here

# Switch to thread 1  
16 SYSCALL PRN 1111 # Debug: switching to thread 1
17 SET 1 21        # Current thread = 1
18 USER 1010       # Switch to user mode, jump to instruction stored in 1010
19 JMP 2           # Should not reach here

# Thread 1 implementation (instructions 20-27)
20 SYSCALL PRN 1001  # Thread 1 message 1
21 SYSCALL PRN 1002  # Thread 1 message 2
22 SYSCALL YIELD     # Yield (goes to instruction 2)
23 SYSCALL PRN 1003  # Thread 1 continues after yield
24 SYSCALL PRN 1004  # Thread 1 message 4
25 SYSCALL YIELD     # Yield again
26 SYSCALL PRN 1005  # Thread 1 final message
27 SYSCALL HLT       # Thread 1 terminates

# Thread 2 implementation (instructions 28-35)
28 SYSCALL PRN 2001  # Thread 2 message 1
29 SYSCALL PRN 2002  # Thread 2 message 2
30 SYSCALL YIELD     # Yield (goes to instruction 2)
31 SYSCALL PRN 2003  # Thread 2 continues after yield
32 SYSCALL PRN 2004  # Thread 2 message 4
33 SYSCALL YIELD     # Yield again
34 SYSCALL PRN 2005  # Thread 2 final message
35 SYSCALL HLT       # Thread 2 terminates

End Instruction Section 