# GTU-C312 Operating System - Complete Round Robin Scheduler
# Demonstrates actual thread switching with YIELD and termination

#✅ Complex context switching logic
#✅ Thread state management
#✅ Active thread counting
#⚠️ Some execution issues
#✅ Full round-robin implementation

Begin Data Section
# Special registers (0-20)
0 0     # Program Counter (PC)
1 500   # Stack Pointer (SP) - starts at 500
2 0     # System call result
3 0     # Number of instructions executed

# OS control variables (21-99)
21 0    # Current thread ID  
22 3    # Number of active threads
23 0    # System tick counter
24 0    # Scheduler state
25 0    # Memory protection flag
26 1    # Next thread to schedule
27 0    # System call type
28 0    # System call parameter
29 0    # Active thread count

# Thread table starts at address 100
# Thread 0 (OS) - 100-109
100 0   # Thread ID
101 0   # Start time
102 0   # Instructions executed  
103 2   # State (2=running)
104 0   # PC
105 500 # SP
106 0   # Reserved
107 0   # Reserved
108 0   # Reserved
109 0   # Reserved

# Thread 1 - 110-119  
110 1   # Thread ID
111 0   # Start time
112 0   # Instructions executed
113 1   # State (1=ready)
114 1000 # PC (start address)
115 600  # SP
116 0   # Reserved
117 0   # Reserved
118 0   # Reserved
119 0   # Reserved

# Thread 2 - 120-129
120 2   # Thread ID  
121 0   # Start time
122 0   # Instructions executed
123 1   # State (1=ready) 
124 2000 # PC (start address)
125 700  # SP
126 0   # Reserved
127 0   # Reserved
128 0   # Reserved
129 0   # Reserved

# Working variables
200 0   # Temp for calculations
201 0   # Temp for thread state
202 0   # Temp for addresses
203 0   # Context switch counter

End Data Section

Begin Instruction Section
# OS Initialization  
0 SYSCALL PRN 100  # Print OS thread ID (0)
1 SYSCALL PRN 22   # Print total threads (3)
2 SET 3 29         # Set active threads = 3

# Scheduler main loop - this is where YIELD returns to
3 SYSCALL PRN 300  # Debug: scheduler entry

# Find next ready thread using round-robin
4 CPY 21 26        # Start with current + 1
5 ADD 26 1         # Next thread
6 SET 3 200        # Check if >= 3 (wrap around)
7 SUBI 200 26      # 3 - next_thread
8 JIF 200 10       # If next < 3, continue
9 SET 0 26         # Wrap to thread 0

# Check if selected thread is ready
10 SET 10 200      # Calculate thread table address
11 ADDI 26 200     # thread_id * 10 (simplified)
12 ADDI 200 200    
13 ADDI 200 200    
14 ADDI 200 200    
15 ADDI 200 200    # Now 200 = thread_id * 10
16 ADD 200 100     # Add base (100)
17 ADD 200 3       # Point to state field
18 CPYI 200 201    # Get state

# Check if thread is active (state 1 or 2)
19 SET 1 202       # Check ready state
20 SUBI 202 201    # 1 - state
21 JIF 202 25      # If state == 1, switch to it

22 SET 2 202       # Check running state  
23 SUBI 202 201    # 2 - state
24 JIF 202 25      # If state == 2, continue with it

# Thread not ready, decrement active count and check termination
25 ADD 29 -1       # Decrement active threads
26 JIF 29 40       # If no active threads, terminate

# Context switch to selected thread
27 SYSCALL PRN 26  # Debug: show selected thread
28 CPY 26 21       # Update current thread

# Save context of previous thread (simplified)
29 SET 10 200      # Calculate previous thread address  
30 ADDI 21 200     
31 ADDI 200 200    
32 ADDI 200 200    
33 ADDI 200 200    
34 ADDI 200 200    
35 ADD 200 100     
36 ADD 200 4       # PC field
37 SET 3 200       # Save return point for scheduler

# Load new thread context
38 SET 10 200      # Calculate new thread address
39 ADDI 26 200     
40 ADDI 200 200    
41 ADDI 200 200    
42 ADDI 200 200    
43 ADDI 200 200    
44 ADD 200 100     
45 ADD 200 4       # PC field  
46 CPYI 200 0      # Load PC
47 ADD 200 1       # SP field
48 CPYI 200 1      # Load SP

# Switch to user mode and execute thread
49 USER 0          # Switch to user mode, jump to PC

# System termination
50 SYSCALL PRN 999 # Print termination marker
51 HLT             # Halt system

# Thread 1 code starts at address 1000
1000 SYSCALL PRN 1001  # Thread 1 says hello
1001 SYSCALL PRN 1002  # Thread 1 working  
1002 SYSCALL YIELD     # Yield to scheduler
1003 SYSCALL PRN 1003  # Thread 1 continues
1004 SYSCALL PRN 1004  # Thread 1 working more
1005 SYSCALL HLT       # Thread 1 terminates

# Thread 2 code starts at address 2000  
2000 SYSCALL PRN 2001  # Thread 2 says hello
2001 SYSCALL PRN 2002  # Thread 2 working
2002 SYSCALL YIELD     # Yield to scheduler  
2003 SYSCALL PRN 2003  # Thread 2 continues
2004 SYSCALL PRN 2004  # Thread 2 working more
2005 SYSCALL HLT       # Thread 2 terminates

End Instruction Section 