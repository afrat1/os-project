# GTU-C312 Operating System - Working Round Robin Scheduler
# ðŸŽ¯ Functional Round-Robin Scheduling with Memory Protection
# âœ… Proper PC management in user-accessible memory
# âœ… SYSCALL YIELD context switching
# âœ… Thread state management
# âœ… Memory protection compliance

Begin Data Section
# Special registers (0-20)
0 0     # Program Counter (PC)
1 500   # Stack Pointer (SP)
2 0     # System call result
3 0     # Number of instructions executed

# OS control variables (21-99)
21 0    # Current thread ID
22 3    # Total number of threads
23 0    # Context switch counter
24 0    # Scheduler flag

# Thread PC storage in user-accessible memory (1000+)
1000 31   # Thread 1 PC (starts at instruction 31)
1001 53   # Thread 2 PC (starts at instruction 53) 
1002 73   # Thread 3 PC (starts at instruction 73)

# Thread state storage
1010 1    # Thread 1 state (1=ready, 0=terminated)
1011 1    # Thread 2 state
1012 1    # Thread 3 state

# Thread data areas
# Thread 1 data (bubble sort)
1020 5    # N
1021 64   # Array[0]
1022 25   # Array[1]
1023 89   # Array[2] 
1024 12   # Array[3]
1025 37   # Array[4]

# Thread 2 data (linear search)
1030 5    # N
1031 37   # Search key
1032 64   # Array[0]
1033 25   # Array[1]
1034 89   # Array[2]
1035 12   # Array[3]
1036 37   # Array[4]
1037 -1   # Result

# Thread 3 data (counter)
1040 0    # Counter
1041 10   # Limit

# Working variables  
1050 0    # Temp 1
1051 0    # Temp 2

End Data Section

Begin Instruction Section
# ========== OS INITIALIZATION ==========
0 SYSCALL PRN 9999    # OS startup marker
1 SET 1 21            # Start with thread 1

# ========== SCHEDULER LOOP ==========
# Entry point for SYSCALL YIELD (instruction 2)
2 ADD 23 1            # Increment context switch counter
3 SYSCALL PRN 23      # Print context switch number
4 SYSCALL PRN 21      # Print current thread

# Round-robin scheduling logic
5 CPY 21 1050         # Get current thread
6 SET 1 1051          # Check if current == 1
7 SUBI 1051 1050      # 1 - current
8 JIF 1051 12         # If current == 1, try thread 2

9 SET 2 1051          # Check if current == 2
10 SUBI 1051 1050     # 2 - current
11 JIF 1051 18        # If current == 2, try thread 3

# Current must be 3, try thread 1
12 CPY 1010 1050      # Check thread 1 state
13 JIF 1050 18        # If terminated, try thread 2
14 SET 1 21           # Switch to thread 1
15 USER 1000          # Jump to thread 1 PC
16 JMP 2              # Should not reach here

# Try thread 2
18 CPY 1011 1050      # Check thread 2 state
19 JIF 1050 24        # If terminated, try thread 3
20 SET 2 21           # Switch to thread 2
21 USER 1001          # Jump to thread 2 PC
22 JMP 2              # Should not reach here

# Try thread 3
24 CPY 1012 1050      # Check thread 3 state
25 JIF 1050 12        # If terminated, back to thread 1
26 SET 3 21           # Switch to thread 3
27 USER 1002          # Jump to thread 3 PC
28 JMP 2              # Should not reach here

# All threads terminated
29 SYSCALL PRN 777    # All done marker
30 HLT                # System halt

# ========== THREAD 1: BUBBLE SORT ==========
31 SYSCALL PRN 1111   # Thread 1 marker
32 SYSCALL PRN 1020   # Print N (5)
33 SYSCALL PRN 1021   # Print array[0] = 64
34 SYSCALL PRN 1022   # Print array[1] = 25
35 SET 37 1000        # Update PC for next execution
36 SYSCALL YIELD      # Yield to scheduler

37 SYSCALL PRN 1023   # Print array[2] = 89
38 SYSCALL PRN 1024   # Print array[3] = 12
39 SYSCALL PRN 1025   # Print array[4] = 37

# Simple bubble sort (one comparison)
40 CPY 1021 1050      # Load array[0] = 64
41 CPY 1022 1051      # Load array[1] = 25
42 SUBI 1050 1051     # 64 - 25 = 39 > 0, need swap
43 JIF 1050 46        # If <= 0, no swap
44 CPY 1022 1021      # Swap: array[0] = 25
45 CPY 1050 1022      # array[1] = 64
46 SET 48 1000        # Update PC
47 SYSCALL YIELD      # Yield

48 SYSCALL PRN 8888   # Sort complete marker
49 SYSCALL PRN 1021   # Print sorted array
50 SYSCALL PRN 1022
51 SET 0 1010         # Mark thread 1 as terminated
52 SYSCALL HLT        # Thread 1 terminates

# ========== THREAD 2: LINEAR SEARCH ==========
53 SYSCALL PRN 2222   # Thread 2 marker  
54 SYSCALL PRN 1030   # Print N (5)
55 SYSCALL PRN 1031   # Print search key (37)
56 SET 58 1001        # Update PC
57 SYSCALL YIELD      # Yield

58 SET -1 1037        # Initialize result = -1
59 CPY 1032 1050      # Load array[0] = 64
60 SUBI 1050 1031     # 64 - 37 = 27 (not zero)
61 JIF 1050 63        # If == 0, found at index 0
62 JMP 64             # Continue

63 SET 0 1037         # Found at index 0
64 CPY 1036 1050      # Load array[4] = 37
65 SUBI 1050 1031     # 37 - 37 = 0 (match!)
66 JIF 1050 68        # If == 0, found
67 JMP 69             # Not found

68 SET 4 1037         # Found at index 4
69 SYSCALL PRN 5555   # Search complete marker
70 SYSCALL PRN 1037   # Print result (4)
71 SET 0 1011         # Mark thread 2 as terminated
72 SYSCALL HLT        # Thread 2 terminates

# ========== THREAD 3: COUNTER ==========
73 SYSCALL PRN 3333   # Thread 3 marker
74 SYSCALL PRN 1041   # Print limit (10)
75 SET 0 1040         # counter = 0
76 SYSCALL PRN 1040   # Print 0
77 SET 79 1002        # Update PC
78 SYSCALL YIELD      # Yield

79 ADD 1040 1         # counter = 1
80 SYSCALL PRN 1040   # Print 1
81 SET 83 1002        # Update PC
82 SYSCALL YIELD      # Yield

83 ADD 1040 1         # counter = 2
84 SYSCALL PRN 1040   # Print 2
85 ADD 1040 1         # counter = 3
86 SYSCALL PRN 1040   # Print 3
87 SYSCALL PRN 4444   # Counter complete marker
88 SET 0 1012         # Mark thread 3 as terminated
89 SYSCALL HLT        # Thread 3 terminates

End Instruction Section 