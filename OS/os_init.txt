# GTU-C312 Operating System - Basic Initialization
# This program demonstrates OS initialization with thread table setup

Begin Data Section
# Special registers (0-20)
0 0     # Program Counter (PC)
1 500   # Stack Pointer (SP) - starts at 500
2 0     # System call result
3 0     # Number of instructions executed

# OS control variables (21-99)
21 0    # Current thread ID
22 0    # Number of active threads
23 0    # System tick counter
24 0    # Scheduler state (0=normal, 1=context switch needed)
25 0    # Memory protection flag (0=kernel mode, 1=user mode)
26 0    # Next thread to schedule
27 0    # System call type (0=none, 1=PRN, 2=YIELD, 3=HLT)
28 0    # System call parameter

# Thread table starts at address 100
# Each thread entry takes 10 memory locations:
# Base + 0: Thread ID
# Base + 1: Start time (instruction count when created)
# Base + 2: Instructions executed by this thread
# Base + 3: Thread state (0=inactive, 1=ready, 2=running, 3=blocked)
# Base + 4: Thread PC
# Base + 5: Thread SP
# Base + 6-9: Reserved for future use

# Thread 0 (OS thread) - starts at address 100
100 0   # Thread ID = 0 (OS)
101 0   # Start time = 0
102 0   # Instructions executed = 0
103 2   # State = 2 (running)
104 0   # PC = 0
105 500 # SP = 500

# Thread 1 - starts at address 110
110 1   # Thread ID = 1
111 0   # Start time (will be set when created)
112 0   # Instructions executed = 0
113 0   # State = 0 (inactive)
114 1000 # PC = 1000 (thread 1 start address)
115 600  # SP = 600 (separate stack)

# Thread 2 - starts at address 120
120 2   # Thread ID = 2
121 0   # Start time
122 0   # Instructions executed
123 0   # State = 0 (inactive)
124 2000 # PC = 2000 (thread 2 start address)
125 700  # SP = 700

# Thread 3 - starts at address 130
130 3   # Thread ID = 3
131 0   # Start time
132 0   # Instructions executed
133 0   # State = 0 (inactive)
134 3000 # PC = 3000 (thread 3 start address)
135 800  # SP = 800

# Initialize remaining threads as inactive
140 4
141 0
142 0
143 0
144 4000
145 900

150 5
151 0
152 0
153 0
154 5000
155 1000

# Test data for demonstration
200 42  # Test value 1
201 100 # Test value 2
202 -5  # Test value 3

End Data Section

Begin Instruction Section
# OS Initialization starts here
0 SET 1 22      # Set number of active threads = 1 (just OS initially)
1 SET 0 21      # Set current thread = 0 (OS)
2 SET 0 25      # Set memory protection to kernel mode
3 SET 0 26      # Set next thread to schedule = 0
4 SET 0 27      # Clear system call type
5 SYSCALL PRN 200  # Print test value to show OS is running

# Thread activation sequence
6 SET 1 113     # Activate thread 1 (set state = 1, ready)
7 ADDI 3 111    # Set thread 1 start time = current instruction count
8 SET 2 22      # Now we have 2 active threads
9 SYSCALL PRN 201  # Print another test value
10 SET 1 123     # Activate thread 2 (set state = 1, ready)
11 ADDI 3 121    # Set thread 2 start time
12 SET 3 22     # Now we have 3 active threads
13 SYSCALL PRN 202 # Print test value
14 SYSCALL PRN 22  # Print number of active threads
15 SYSCALL PRN 21  # Print current thread ID

# Scheduler implementation
16 SET 1 24     # Set scheduler state to context switch needed
17 SET 1 26     # Set next thread to schedule = 1
18 SET 2 27     # Set system call type to YIELD
19 SYSCALL PRN 26  # Print next thread to schedule
20 HLT          # Halt the system

# System call handlers (these would be implemented in the CPU simulator)
# PRN handler: Print value at memory location specified in system call parameter
# YIELD handler: Save current thread state, load next thread state
# HLT handler: Mark thread as inactive, schedule next thread

# Thread implementations would go here
# Thread 1 (Sorting) starts at 1000
# Thread 2 (Linear Search) starts at 2000
# Thread 3 (Custom) starts at 3000

End Instruction Section 