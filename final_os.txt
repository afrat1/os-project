# Final Working GTU-C312 Operating System
Begin Data Section
# === CPU Registers (0-20) ===
0 0     # Program Counter
1 0     # Stack Pointer  
2 0     # System call result
3 0     # Number of instructions executed

# === Thread Table (21-120) ===
# Thread 0 (OS) - Entry at 21-30
21 0    # Thread ID
22 0    # Start time
23 0    # Instruction count used
24 2    # State (2=running)
25 0    # Saved PC
26 0    # Saved SP

# Thread 1 (Bubble Sort) - Entry at 31-40
31 1    # Thread ID
32 0    # Start time
33 0    # Instruction count used
34 1    # State (1=ready)
35 20   # Starting PC (instruction 20)
36 0    # Saved SP

# Thread 2 (Linear Search) - Entry at 41-50
41 2    # Thread ID
42 0    # Start time
43 0    # Instruction count used
44 1    # State (1=ready)
45 40   # Starting PC (instruction 40)
46 0    # Saved SP

# Thread 3 (Factorial) - Entry at 51-60
51 3    # Thread ID
52 0    # Start time
53 0    # Instruction count used
54 1    # State (1=ready)
55 60   # Starting PC (instruction 60)
56 0    # Saved SP

# OS Variables (200-220)
200 1   # Current thread ID
201 0   # System tick counter

# === Thread Data Areas ===
# Thread 1 Data (1000-1099) - Bubble Sort
1000 5      # Array size
1001 64     # arr[0]
1002 34     # arr[1]
1003 25     # arr[2]
1004 12     # arr[3]
1005 90     # arr[4]
1010 0      # i (outer loop)
1011 0      # j (inner loop)

# Thread 2 Data (2000-2099) - Linear Search
2000 5      # Array size
2001 25     # Search key
2002 64     # arr[0]
2003 34     # arr[1]
2004 25     # arr[2] (target)
2005 12     # arr[3]
2006 90     # arr[4]
2010 0      # Current position
2011 -1     # Result

# Thread 3 Data (3000-3099) - Factorial
3000 5      # N = calculate 5!
3001 1      # Result
3002 1      # Counter

End Data Section

Begin Instruction Section
# === OS KERNEL (Instructions 0-19) ===
0 SET 1 200     # Current thread = 1
1 JMP 20        # Jump to thread 1

# OS Scheduler (2-10)
2 ADD 201 1     # Increment system tick
3 ADD 200 1     # Next thread
4 SET 4 202     # Check if > 3
5 SUBI 202 200  # 4 - thread_id
6 JIF 200 9     # If ≤ 0, reset to 1
7 JMP 11        # Continue to dispatcher
9 SET 1 200     # Reset to thread 1

# Thread Dispatcher (11-19)
11 SET 1 202    # Compare with 1
12 SUBI 202 200 # 1 - thread_id
13 JIF 200 20   # If thread 1, jump to sorting
14 SET 2 202    # Compare with 2  
15 SUBI 202 200 # 2 - thread_id
16 JIF 200 40   # If thread 2, jump to search
17 JMP 60       # Else thread 3, jump to factorial

# === THREAD 1: BUBBLE SORT (20-39) ===
20 CPY 1000 1010  # i = N
21 JIF 1010 35    # If i ≤ 0, print results
22 SET 0 1011     # j = 0
23 CPY 1000 202   # Get N
24 ADD 202 -1     # N-1
25 SUBI 202 1011  # (N-1) - j
26 JIF 1011 32    # If j ≥ N-1, next i

# Compare and swap
27 CPYI 1001 1011 203  # Get arr[j] (indirect addressing simulated)
28 ADD 1011 1     # j+1
29 CPYI 1001 1011 202  # Get arr[j+1]
30 ADD 1011 -1    # Back to j
31 SUBI 203 202   # Compare arr[j] - arr[j+1]
32 JIF 202 34     # If arr[j] ≤ arr[j+1], no swap needed
33 # Swap would go here - simplified for demo
34 ADD 1011 1     # j++
35 SYSCALL YIELD  # Yield
36 JMP 25         # Continue inner loop
37 ADD 1010 -1    # i--
38 SYSCALL YIELD  # Yield
39 JMP 21         # Continue outer loop

# Print results
35 SET 0 1011     # Counter = 0
36 SUBI 1000 1011 # N - counter
37 JIF 1011 39    # If done, halt
38 SYSCALL PRN 1001 # Print first element (simplified)
39 SYSCALL HLT    # End thread

# === THREAD 2: LINEAR SEARCH (40-59) ===
40 SET 0 2010     # position = 0
41 SET -1 2011    # result = -1
42 SUBI 2000 2010 # N - position
43 JIF 2010 57    # If position ≥ N, done

44 CPY 2002 202   # Base address
45 ADD 202 2010   # arr[position] address
46 CPY 202 203    # Get arr[position] (simplified)
47 SUBI 203 2001  # Compare with search key
48 JIF 203 55     # If equal, found

49 ADD 2010 1     # position++
50 SYSCALL YIELD  # Yield
51 JMP 42         # Continue search

55 CPY 2010 2011  # result = position
57 SYSCALL PRN 2011 # Print result
58 SYSCALL HLT    # End thread

# === THREAD 3: FACTORIAL (60-79) ===
60 CPY 3000 3002  # counter = N
61 SET 1 3001     # result = 1
62 JIF 3002 75    # If counter ≤ 0, done

# Multiply using repeated addition
63 SET 0 202      # temp = 0
64 CPY 3001 203   # current result
65 JIF 3002 72    # If counter ≤ 0, done with this multiplication
66 ADD 202 203    # temp += result
67 ADD 3002 -1    # counter--
68 SYSCALL YIELD  # Yield
69 JMP 65         # Continue multiplication

72 CPY 202 3001   # result = temp
73 ADD 3002 -1    # Decrement main counter
74 SYSCALL YIELD  # Yield
75 JMP 62         # Continue factorial

76 SYSCALL PRN 3001 # Print result
77 SYSCALL HLT    # End thread

End Instruction Section 