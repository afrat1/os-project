# Complete GTU-C312 Operating System with Full Thread Table
Begin Data Section
# === CPU Registers (0-20) ===
0 0     # Program Counter
1 0     # Stack Pointer  
2 0     # System call result
3 0     # Number of instructions executed
4 0     # Reserved
5 0     # Reserved
6 0     # Reserved
7 0     # Reserved
8 0     # Reserved
9 0     # Reserved
10 0    # Reserved
11 0    # Reserved
12 0    # Reserved
13 0    # Reserved
14 0    # Reserved
15 0    # Reserved
16 0    # Reserved
17 0    # Reserved
18 0    # Reserved
19 0    # Reserved
20 0    # Reserved

# === OS Data Area (21-999) ===
# Thread Table Structure (10 threads * 7 words each = 70 words)
# Each thread entry: [ID, StartTime, InstrCount, State, PC, SP, Reserved]

# Thread 0 (OS itself) - Entry at 21-27
21 0    # Thread ID
22 0    # Start time
23 0    # Instruction count used
24 2    # State (2=running - OS starts running)
25 0    # Saved PC
26 0    # Saved SP
27 0    # Reserved

# Thread 1 (Sorting Thread) - Entry at 28-34
28 1    # Thread ID
29 0    # Start time
30 0    # Instruction count used
31 1    # State (1=ready)
32 20   # PC (starting instruction - CORRECTED)
33 1100 # SP (stack area)
34 0    # Reserved

# Thread 2 (Search Thread) - Entry at 35-41
35 2    # Thread ID
36 0    # Start time
37 0    # Instruction count used
38 1    # State (1=ready)
39 40   # PC (starting instruction - CORRECTED)
40 2100 # SP (stack area)
41 0    # Reserved

# Thread 3 (Custom/Factorial Thread) - Entry at 42-48
42 3    # Thread ID
43 0    # Start time
44 0    # Instruction count used
45 1    # State (1=ready)
46 55   # PC (starting instruction - CORRECTED)
47 3100 # SP (stack area)
48 0    # Reserved

# Threads 4-9 (inactive) - Entries at 49-90
49 4    # Thread ID
50 0    # Start time
51 0    # Instruction count used
52 0    # State (0=inactive)
53 0    # PC
54 0    # SP
55 0    # Reserved

# OS Variables (200-250)
200 1   # Current thread ID
201 0   # Scheduler counter
202 0   # System tick counter
203 1   # Next thread to schedule

# === Thread Data Areas ===
# Thread 1 Data (1000-1099) - Sorting data
1000 5      # N = number of elements to sort
1001 64     # Element 0
1002 34     # Element 1
1003 25     # Element 2
1004 12     # Element 3
1005 90     # Element 4
1006 0      # Temp storage for sorting
1007 0      # Loop counter i
1008 0      # Loop counter j
1009 0      # Temp for swapping

# Thread 2 Data (2000-2099) - Search data
2000 5      # N = number of elements
2001 25     # Search key
2002 64     # Element 0
2003 34     # Element 1
2004 25     # Element 2 (this should be found at position 2)
2005 12     # Element 3
2006 90     # Element 4
2007 0      # Current position being checked
2008 -1     # Result (-1 = not found, else position)

# Thread 3 Data (3000-3099) - Factorial data
3000 5      # N = calculate factorial of 5
3001 1      # Result storage
3002 1      # Counter

End Data Section

Begin Instruction Section
# === OS KERNEL (Instructions 0-19) ===

# OS Bootup and Initialization (0-1) 
0 SET 1 200     # Set current thread to 1 (start with sorting)
1 JMP 20        # Jump to thread 1 (sorting thread)

# OS Scheduler - Return point from SYSCALL YIELD (2-11)
2 ADD 202 1     # Increment system tick
3 CPY 200 201   # Get current thread
4 ADD 200 1     # Switch to next thread
5 SET 4 201     # Check if thread > 3
6 SUBI 201 200  # 4 - current_thread, result in current_thread
7 JIF 200 10    # If result ≤ 0 (thread was 4), reset to 1
8 JMP 12        # Continue with current thread
9 HLT           # Placeholder
10 SET 1 200    # Reset to thread 1
11 JMP 12       # Continue to dispatcher

# Jump to appropriate thread (12-19)
12 CPY 200 201  # Get current thread ID
13 SET 1 204    # Check if thread == 1
14 SUBI 204 201 # 1 - thread_id
15 JIF 201 20   # If thread == 1, jump to sorting (instruction 20)
16 SET 2 204    # Check if thread == 2
17 SUBI 204 201 # 2 - thread_id  
18 JIF 201 40   # If thread == 2, jump to search (instruction 40)
19 JMP 55       # Otherwise thread == 3, jump to factorial (instruction 55)

# === THREAD 1: BUBBLE SORT ALGORITHM (20-39) ===
20 CPY 1000 1007  # i = N (outer loop counter)
21 JIF 1007 37    # If i ≤ 0, sorting done
22 SET 0 1008     # j = 0 (inner loop counter)
23 CPY 1000 1009  # temp = N
24 ADD 1009 -1    # temp = N-1
25 SUBI 1009 1008 # Compare j with N-1
26 JIF 1008 34    # If j ≥ N-1, inner loop done

# Bubble sort comparison and swap (27-33)
27 SET 1001 1009  # Base address of array
28 ADD 1009 1008  # Address of arr[j]
29 CPY 1009 203   # Get arr[j]
30 ADD 1009 1     # Address of arr[j+1]
31 CPY 1009 204   # Get arr[j+1]
32 SUBI 203 204   # Compare: arr[j] - arr[j+1]
33 JIF 204 35     # If arr[j] ≤ arr[j+1], no swap needed

# Inner loop increment
34 ADD 1008 1     # j++
35 SYSCALL YIELD  # Yield to other threads
36 JMP 25         # Continue inner loop

# Outer loop increment  
37 ADD 1007 -1    # i--
38 SYSCALL YIELD  # Yield to other threads
39 JMP 21         # Continue outer loop

# === THREAD 2: LINEAR SEARCH (40-54) ===
40 SET 0 2007     # position = 0
41 SET -1 2008    # result = -1 (not found)
42 CPY 2000 1009  # Get N
43 SUBI 1009 2007 # N - position
44 JIF 2007 53    # If position ≥ N, search complete

45 SET 2002 1009  # Base address of array
46 ADD 1009 2007  # Address of arr[position]
47 CPY 1009 203   # Get arr[position]
48 CPY 2001 204   # Get search key
49 SUBI 203 204   # Compare: arr[position] - key
50 JIF 204 52     # If equal, found it

51 ADD 2007 1     # position++
52 JMP 42         # Continue search
53 SYSCALL PRN 2008 # Print result (-1 or position)
54 SYSCALL HLT    # End search thread

# Found it case (instruction 52)
52 CPY 2007 2008  # result = position (found!)
53 SYSCALL PRN 2008 # Print result
54 SYSCALL HLT    # End search thread

# === THREAD 3: FACTORIAL CALCULATION (55-71) ===
55 CPY 3000 3002  # counter = N
56 SET 1 3001     # result = 1
57 JIF 3002 70    # If counter ≤ 0, done

# Multiply result by counter (using repeated addition)
58 SET 0 1009     # temp = 0 (for multiplication by addition)
59 CPY 3001 203   # current result
60 CPY 3002 204   # current counter
61 JIF 204 67     # If counter ≤ 0, multiplication done
62 ADD 1009 203   # temp += result (multiply by repeated addition)
63 ADD 204 -1     # counter--
64 SYSCALL YIELD  # Yield during multiplication
65 JMP 61         # Continue multiplication

# Store result and continue
66 CPY 1009 3001  # result = temp (new factorial value)
67 ADD 3002 -1    # counter--
68 SYSCALL YIELD  # Yield to other threads
69 JMP 57         # Continue factorial calculation

# Print result and halt
70 SYSCALL PRN 3001 # Print factorial result
71 SYSCALL HLT    # End factorial thread

End Instruction Section 