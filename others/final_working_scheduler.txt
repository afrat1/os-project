# GTU-C312 Operating System - Final Working Round Robin Scheduler
# Properly handles memory protection and USER instruction

#✅ Memory protection handling
#✅ USER instruction usage
#❌ PC bounds error (instruction mapping issue)
#✅ Thread table structure
#✅ Context switch counter

Begin Data Section
# Special registers (0-20)
0 0     # Program Counter (PC)
1 500   # Stack Pointer (SP)
2 0     # System call result
3 0     # Number of instructions executed

# OS control variables (21-99)
21 0    # Current thread ID
22 3    # Total threads
23 0    # System tick counter
24 0    # Scheduler state
25 0    # Context switch counter

# Thread table starting at address 100
# Thread 0 (OS) - addresses 100-109
100 0   # Thread ID
101 0   # Start time
102 0   # Instructions executed
103 2   # State (2=running)
104 2   # PC
105 500 # SP
106 0   # Reserved
107 0   # Reserved
108 0   # Reserved
109 0   # Reserved

# Thread 1 - addresses 110-119
110 1   # Thread ID
111 0   # Start time
112 0   # Instructions executed
113 1   # State (1=ready)
114 1000 # PC (start address)
115 600  # SP
116 0   # Reserved
117 0   # Reserved
118 0   # Reserved
119 0   # Reserved

# Thread 2 - addresses 120-129
120 2   # Thread ID
121 0   # Start time
122 0   # Instructions executed
123 1   # State (1=ready)
124 2000 # PC (start address)
125 700  # SP
126 0   # Reserved
127 0   # Reserved
128 0   # Reserved
129 0   # Reserved

# Working variables (still in kernel space)
200 0   # Temp variable
201 0   # Thread state
202 0   # Next thread

# PC storage in user-accessible memory (>= 1000)
1010 1000 # Thread 1 PC storage (for USER instruction)
1011 2000 # Thread 2 PC storage (for USER instruction)
1012 1003 # Thread 1 resume PC after first yield
1013 2003 # Thread 2 resume PC after first yield
1014 1006 # Thread 1 resume PC after second yield
1015 2006 # Thread 2 resume PC after second yield

End Data Section

Begin Instruction Section
# OS Initialization
0 SYSCALL PRN 888  # OS startup marker
1 SET 0 21         # Current thread = 0

# Scheduler entry point (instruction 2)
# SYSCALL YIELD jumps here automatically
2 ADD 25 1         # Increment context switch counter
3 SYSCALL PRN 25   # Print context switch number for debugging

# Simple round-robin: alternate between threads 1 and 2
4 CPY 21 202       # Get current thread
5 SET 1 200        # Check if current is thread 1
6 SUBI 200 202     # 1 - current
7 JIF 200 12       # If current == 1, switch to thread 2

8 SET 2 200        # Check if current is thread 2
9 SUBI 200 202     # 2 - current
10 JIF 200 16      # If current == 2, switch to thread 1

# Default: start with thread 1
11 JMP 16          # Go to thread 1

# Switch to thread 2
12 SYSCALL PRN 2222 # Debug: switching to thread 2
13 SET 2 21        # Current thread = 2
14 USER 1011       # Switch to user mode, jump to address in 1011 (2000)
15 JMP 2           # Should not reach here

# Switch to thread 1  
16 SYSCALL PRN 1111 # Debug: switching to thread 1
17 SET 1 21        # Current thread = 1
18 USER 1010       # Switch to user mode, jump to address in 1010 (1000)
19 JMP 2           # Should not reach here

# Thread implementations

# Thread 1 - Simple demonstration
1000 SYSCALL PRN 1001  # Thread 1 message 1
1001 SYSCALL PRN 1002  # Thread 1 message 2
1002 SYSCALL YIELD     # Yield (goes to instruction 2)
1003 SYSCALL PRN 1003  # Thread 1 continues after yield
1004 SYSCALL PRN 1004  # Thread 1 message 4
1005 SYSCALL YIELD     # Yield again
1006 SYSCALL PRN 1005  # Thread 1 final message
1007 SYSCALL HLT       # Thread 1 terminates

# Thread 2 - Another demonstration
2000 SYSCALL PRN 2001  # Thread 2 message 1
2001 SYSCALL PRN 2002  # Thread 2 message 2
2002 SYSCALL YIELD     # Yield (goes to instruction 2)
2003 SYSCALL PRN 2003  # Thread 2 continues after yield
2004 SYSCALL PRN 2004  # Thread 2 message 4
2005 SYSCALL YIELD     # Yield again
2006 SYSCALL PRN 2005  # Thread 2 final message
2007 SYSCALL HLT       # Thread 2 terminates

End Instruction Section 