# GTU-C312 Operating System with Threads
# This file contains the complete OS and thread programs

Begin Data Section
# === CPU Registers (0-20) ===
0 0     # Program Counter
1 0     # Stack Pointer  
2 0     # System call result
3 0     # Number of instructions executed
4 0     # Reserved
5 0     # Reserved
6 0     # Reserved
7 0     # Reserved
8 0     # Reserved
9 0     # Reserved
10 0    # Reserved
11 0    # Reserved
12 0    # Reserved
13 0    # Reserved
14 0    # Reserved
15 0    # Reserved
16 0    # Reserved
17 0    # Reserved
18 0    # Reserved
19 0    # Reserved
20 0    # Reserved

# === OS Data Area (21-999) ===
# Thread Table Structure (10 threads * 10 words each = 100 words)
# Each thread entry: [ID, StartTime, InstrCount, State, PC, SP, Reserved1-4]

# Thread 0 (OS itself)
21 0    # Thread ID
22 0    # Start time
23 0    # Instruction count used
24 2    # State (2=running - OS starts running)
25 0    # Saved PC
26 0    # Saved SP
27 0    # Reserved
28 0    # Reserved  
29 0    # Reserved
30 0    # Reserved

# Thread 1 (Sorting Thread - starts at address 1000)
31 1    # Thread ID
32 0    # Start time
33 0    # Instruction count used
34 1    # State (1=ready)
35 1000 # PC (starting address)
36 1100 # SP (stack area)
37 0    # Reserved
38 0    # Reserved
39 0    # Reserved
40 0    # Reserved

# Thread 2 (Search Thread - starts at address 2000)
41 2    # Thread ID
42 0    # Start time
43 0    # Instruction count used
44 1    # State (1=ready)
45 2000 # PC (starting address)
46 2100 # SP (stack area)
47 0    # Reserved
48 0    # Reserved
49 0    # Reserved
50 0    # Reserved

# Thread 3 (Custom Thread - starts at address 3000)
51 3    # Thread ID
52 0    # Start time
53 0    # Instruction count used
54 1    # State (1=ready)
55 3000 # PC (starting address)
56 3100 # SP (stack area)
57 0    # Reserved
58 0    # Reserved
59 0    # Reserved
60 0    # Reserved

# Threads 4-9 (inactive for now)
61 4    # Thread ID
62 0    # Start time
63 0    # Instruction count used
64 0    # State (0=inactive)
65 0    # PC
66 0    # SP
67 0    # Reserved
68 0    # Reserved
69 0    # Reserved
70 0    # Reserved

# ... (repeat for threads 5-9, addresses 71-120)

# OS Variables
200 0   # Current thread ID (currently running thread)
201 0   # Scheduler counter
202 0   # System tick counter
203 0   # Next thread to schedule
204 0   # Temp storage for context switch
205 0   # Temp storage for thread table address calculation
206 0   # Temp storage for old PC
207 0   # Temp storage for old SP

# === Thread Data Areas ===
# Thread 1 Data (1000-1099) - Sorting data
1000 5      # N = number of elements to sort
1001 64     # Element 1
1002 34     # Element 2  
1003 25     # Element 3
1004 12     # Element 4
1005 90     # Element 5
1006 0      # Temp storage for sorting
1007 0      # Loop counter i
1008 0      # Loop counter j
1009 0      # Temp for swapping

# Thread 2 Data (2000-2099) - Search data
2000 5      # N = number of elements
2001 25     # Search key
2002 64     # Element 1
2003 34     # Element 2
2004 25     # Element 3 (this should be found at position 2, 0-indexed)
2005 12     # Element 4
2006 90     # Element 5
2007 0      # Current position being checked
2008 -1     # Result (-1 = not found, else position)

# Thread 3 Data (3000-3099) - Custom program data  
3000 10     # N = calculate factorial of 10
3001 1      # Result storage
3002 1      # Counter

End Data Section

Begin Instruction Section
# === OS KERNEL (Instructions 0-999) ===

# OS Bootup and Initialization (0-19)
0 SET 0 200     # Set current thread to 0 (OS)
1 SET 0 201     # Initialize scheduler counter
2 SET 0 202     # Initialize system tick counter
3 SET 1 203     # Next thread to schedule = 1
4 JMP 20        # Jump directly to scheduler (don't start user mode yet)

# OS Scheduler Entry Point (5-19) - return point from SYSCALL
5 JMP 20        # Jump to main scheduler loop

# OS Main Scheduler Loop (20-49)  
20 ADD 202 1    # Increment system tick

# Check if YIELD was called (SYSCALL_RESULT_ADDR = 2 will be set)
21 CPY 2 204    # Copy syscall result to temp
22 SET 0 2      # Clear syscall result
23 JIF 204 30   # If no yield (≤ 0), continue current thread
24 JMP 50       # If yield was called, do context switch

# Continue current thread - no context switch needed (25-39)
25 JMP 70       # Jump to restore and continue current thread

# Context Switch Implementation (50-69)
50 CALL 100     # Call save current thread context
51 CALL 120     # Call find next thread
52 JMP 70       # Jump to restore and continue

# Restore and Continue Thread (70-89)
70 CALL 140     # Call restore thread context  
71 CPY 204 0    # Set PC to thread's PC (stored in temp 204)
72 USER 1000    # Switch to user mode (address doesn't matter, PC already set)

# === SYSTEM CALL HANDLERS (100-199) ===

# Save Current Thread Context (100-119)
100 CPY 200 205 # Get current thread ID  
101 SET 21 204  # Base address of thread table
102 SET 10 206  # Multiplier = 10
103 SET 0 207   # Initialize counter for multiplication
104 JIF 205 110 # If threadID <= 0, skip multiplication
105 ADD 207 206 # Add 10 to counter
106 ADD 205 -1  # Decrement threadID
107 JMP 104     # Continue multiplication loop
110 ADD 204 207 # Add offset to base address
111 CPY 0 206   # Save current PC
112 CPY 1 207   # Save current SP
113 ADD 204 4   # Point to PC field in thread table
114 SET 206 204 # Store PC in thread table (direct SET)
115 ADD 204 1   # Point to SP field
116 SET 207 204 # Store SP in thread table
117 RET         # Return from save context

# Find Next Thread (Round Robin) (120-139)
120 CPY 203 200 # Set current thread = next thread
121 ADD 203 1   # Increment next thread counter
122 SET 4 204   # Check if next > 3
123 SUBI 204 203 # 4 - next, result in next
124 JIF 203 127 # If next <= 0 (i.e., was 4), reset
125 JMP 130     # Continue
127 SET 1 203   # Reset next thread to 1
128 CPY 203 200 # Update current thread
130 RET         # Return from find next thread

# Restore Thread Context (140-159)
140 CPY 200 205 # Get current thread ID
141 SET 21 204  # Base address of thread table
142 SET 10 206  # Multiplier = 10
143 SET 0 207   # Initialize counter for multiplication
144 JIF 205 150 # If threadID <= 0, skip multiplication
145 ADD 207 206 # Add 10 to counter
146 ADD 205 -1  # Decrement threadID
147 JMP 144     # Continue multiplication loop
150 ADD 204 207 # Add offset to base address
151 ADD 204 4   # Point to PC field
152 CPY 204 206 # Load thread's PC into temp
153 ADD 204 1   # Point to SP field
154 CPY 204 207 # Load thread's SP into temp
155 CPY 207 1   # Restore CPU SP
156 CPY 206 204 # Store PC in temp 204 for later use
157 RET         # Return from restore context

# SYSCALL HLT Handler (160-179)
160 CPY 200 205 # Get current thread ID
161 SET 10 204  # Calculate offset
162 SUBI 204 205 # offset = 10 * threadID
163 ADD 204 21  # Add base address  
164 ADD 204 3   # Point to state field
165 SET 0 204   # Set state to inactive (0)
166 CALL 120    # Find next thread
167 CALL 140    # Restore next thread
168 JMP 80      # Continue execution

# SYSCALL YIELD Handler (180-199) 
180 SET 1 2     # Set syscall result to indicate YIELD
181 JMP 5       # Return to scheduler entry point

# === THREAD 1: SORTING ALGORITHM (1000-1999) ===
1000 SET 1000 1007  # i = N (5)
1001 SET 0 1008     # j = 0
1002 JIF 1007 1050  # If i ≤ 0, done sorting
1003 SET 0 1008     # Reset j = 0 for inner loop
1004 CPY 1000 1009  # temp = N
1005 ADD 1009 -1    # temp = N-1
1006 SUBI 1009 1008 # temp = (N-1) - j, store in j
1007 JIF 1008 1045  # If j ≤ 0, inner loop done

# Bubble sort comparison and swap
1008 SET 1001 1009  # Base address of array
1009 ADD 1009 1008  # Address of arr[j]
1010 CPY 1009 204   # Get arr[j]
1011 ADD 1009 1     # Address of arr[j+1]  
1012 CPY 1009 205   # Get arr[j+1]
1013 SUBI 204 205   # Compare: arr[j] - arr[j+1], result in arr[j+1] addr
1014 JIF 205 1040   # If arr[j] ≤ arr[j+1], no swap needed

# Swap elements
1015 SET 1001 1009  # Base address
1016 ADD 1009 1008  # arr[j] address
1017 CPY 1009 206   # temp = arr[j]
1018 CPY 205 1009   # arr[j] = arr[j+1]
1019 ADD 1009 1     # arr[j+1] address
1020 CPY 206 1009   # arr[j+1] = temp

1040 ADD 1008 1     # j++
1041 SYSCALL YIELD  # Yield to other threads
1042 JMP 1007       # Continue inner loop

1045 ADD 1007 -1    # i--
1046 SYSCALL YIELD  # Yield to other threads  
1047 JMP 1002       # Continue outer loop

# Print sorted results
1050 SET 0 1008     # i = 0
1051 CPY 1000 1009  # Get N
1052 SUBI 1009 1008 # N - i, store in i
1053 JIF 1008 1060  # If i ≤ 0, done printing
1054 SET 1001 1009  # Base address
1055 ADD 1009 1008  # Address of arr[i]
1056 SYSCALL PRN 1009 # Print arr[i]
1057 ADD 1008 1     # i++
1058 SYSCALL YIELD  # Yield
1059 JMP 1052       # Continue printing
1060 SYSCALL HLT    # End thread

# === THREAD 2: LINEAR SEARCH (2000-2999) ===
2000 SET 0 2007     # position = 0
2001 SET -1 2008    # result = -1 (not found)
2002 CPY 2000 1009  # Get N
2003 SUBI 1009 2007 # N - position, store in position
2004 JIF 2007 2020  # If position ≤ 0, search complete

2005 SET 2002 1009  # Base address of array
2006 ADD 1009 2007  # Address of arr[position]
2007 CPY 1009 204   # Get arr[position]
2008 CPY 2001 205   # Get search key
2009 SUBI 204 205   # Compare: arr[position] - key, result in key
2010 JIF 205 2015   # If equal (≤ 0), found it

2011 ADD 2007 1     # position++
2012 SYSCALL YIELD  # Yield to other threads
2013 JMP 2003       # Continue search

2015 CPY 2007 2008  # result = position (found!)
2016 JMP 2020       # Jump to print result

2020 SYSCALL PRN 2008 # Print result (-1 or position)
2021 SYSCALL HLT    # End thread

# === THREAD 3: FACTORIAL CALCULATION (3000-3999) ===
3000 CPY 3000 3002  # counter = N (10)
3001 SET 1 3001     # result = 1
3002 JIF 3002 3010  # If counter ≤ 0, done

3003 ADDI 3001 3002 # result = result * counter (using addition in loop)
3004 ADD 3002 -1    # counter--
3005 SYSCALL YIELD  # Yield to other threads
3006 JMP 3002       # Continue loop

3010 SYSCALL PRN 3001 # Print factorial result
3011 SYSCALL HLT    # End thread

End Instruction Section 