# Complete GTU-C312 Operating System with Full Thread Table
Begin Data Section
# === CPU Registers (0-20) ===
0 0     # Program Counter
1 0     # Stack Pointer  
2 0     # System call result
3 0     # Number of instructions executed
4 0     # Reserved
5 0     # Reserved
6 0     # Reserved
7 0     # Reserved
8 0     # Reserved
9 0     # Reserved
10 0    # Reserved
11 0    # Reserved
12 0    # Reserved
13 0    # Reserved
14 0    # Reserved
15 0    # Reserved
16 0    # Reserved
17 0    # Reserved
18 0    # Reserved
19 0    # Reserved
20 0    # Reserved

# === OS Data Area (21-999) ===
# Thread Table Structure (10 threads * 7 words each = 70 words)
# Each thread entry: [ID, StartTime, InstrCount, State, PC, SP, Reserved]

# Thread 0 (OS itself) - Entry at 21-27
21 0    # Thread ID
22 0    # Start time
23 0    # Instruction count used
24 2    # State (2=running - OS starts running)
25 0    # Saved PC
26 0    # Saved SP
27 0    # Reserved

# Thread 1 (Sorting Thread) - Entry at 28-34
28 1    # Thread ID
29 0    # Start time
30 0    # Instruction count used
31 1    # State (1=ready)
32 50   # PC (starting instruction)
33 1100 # SP (stack area)
34 0    # Reserved

# Thread 2 (Search Thread) - Entry at 35-41
35 2    # Thread ID
36 0    # Start time
37 0    # Instruction count used
38 1    # State (1=ready)
39 100  # PC (starting instruction)
40 2100 # SP (stack area)
41 0    # Reserved

# Thread 3 (Custom/Factorial Thread) - Entry at 42-48
42 3    # Thread ID
43 0    # Start time
44 0    # Instruction count used
45 1    # State (1=ready)
46 150  # PC (starting instruction)
47 3100 # SP (stack area)
48 0    # Reserved

# Threads 4-9 (inactive) - Entries at 49-90
49 4    # Thread ID
50 0    # Start time
51 0    # Instruction count used
52 0    # State (0=inactive)
53 0    # PC
54 0    # SP
55 0    # Reserved

# OS Variables (200-250)
200 1   # Current thread ID
201 0   # Scheduler counter
202 0   # System tick counter
203 1   # Next thread to schedule

# === Thread Data Areas ===
# Thread 1 Data (1000-1099) - Sorting data
1000 5      # N = number of elements to sort
1001 64     # Element 0
1002 34     # Element 1
1003 25     # Element 2
1004 12     # Element 3
1005 90     # Element 4
1006 0      # Temp storage for sorting
1007 0      # Loop counter i
1008 0      # Loop counter j
1009 0      # Temp for swapping
1010 50     # Thread 1 starting instruction address

# Thread 2 Data (2000-2099) - Search data
2000 5      # N = number of elements
2001 25     # Search key
2002 64     # Element 0
2003 34     # Element 1
2004 25     # Element 2 (this should be found at position 2)
2005 12     # Element 3
2006 90     # Element 4
2007 0      # Current position being checked
2008 -1     # Result (-1 = not found, else position)
2009 100    # Thread 2 starting instruction address

# Thread 3 Data (3000-3099) - Factorial data
3000 5      # N = calculate factorial of 5
3001 1      # Result storage
3002 1      # Counter
3003 150    # Thread 3 starting instruction address

End Data Section

Begin Instruction Section
# === OS KERNEL (Instructions 0-49) ===

# OS Bootup and Initialization (0-9)
0 SET 1 200     # Set current thread to 1 (start with sorting)
1 JMP 50        # Jump directly to thread 1 (sorting thread)

# OS Scheduler - Return point from SYSCALL YIELD (2-19)
2 ADD 202 1     # Increment system tick
3 CPY 200 201   # Get current thread
4 ADD 200 1     # Switch to next thread
5 SET 4 201     # Check if thread > 3
6 SUBI 201 200  # 4 - current_thread, result in current_thread
7 JIF 200 10    # If result ≤ 0 (thread was 4), reset to 1
8 JMP 12        # Continue with current thread
10 SET 1 200    # Reset to thread 1

# Jump to appropriate thread (12-19)
12 CPY 200 201  # Get current thread ID
13 SET 1 204    # Check if thread == 1
14 SUBI 204 201 # 1 - thread_id
15 JIF 201 50   # If thread == 1, jump to sorting (instruction 50)
16 SET 2 204    # Check if thread == 2
17 SUBI 204 201 # 2 - thread_id  
18 JIF 201 100  # If thread == 2, jump to search (instruction 100)
19 JMP 150      # Otherwise thread == 3, jump to factorial (instruction 150)

# === THREAD 1: BUBBLE SORT ALGORITHM (50-99) ===
50 SET 1000 1007  # i = N (outer loop counter)
51 JIF 1007 90    # If i ≤ 0, sorting done
52 SET 0 1008     # j = 0 (inner loop counter)
53 CPY 1000 1009  # temp = N
54 ADD 1009 -1    # temp = N-1
55 SUBI 1009 1008 # Compare j with N-1
56 JIF 1008 85    # If j ≥ N-1, inner loop done

# Bubble sort comparison and swap (57-75)
57 SET 1001 1009  # Base address of array
58 ADD 1009 1008  # Address of arr[j]
59 CPY 1009 203   # Get arr[j]
60 ADD 1009 1     # Address of arr[j+1]
61 CPY 1009 204   # Get arr[j+1]
62 SUBI 203 204   # Compare: arr[j] - arr[j+1]
63 JIF 204 80     # If arr[j] ≤ arr[j+1], no swap needed

# Swap elements (64-70)
64 SET 1001 1009  # Base address
65 ADD 1009 1008  # arr[j] address
66 CPY 203 1009   # arr[j] = temp (arr[j])
67 ADD 1009 1     # arr[j+1] address  
68 CPY 204 1009   # arr[j+1] = arr[j+1]
69 ADD 1009 -1    # Back to arr[j]
70 CPY 204 1009   # Complete the swap

80 ADD 1008 1     # j++
81 SYSCALL YIELD  # Yield to other threads
82 JMP 56         # Continue inner loop

85 ADD 1007 -1    # i--
86 SYSCALL YIELD  # Yield to other threads
87 JMP 51         # Continue outer loop

# Print sorted results (90-99)
90 SET 0 1008     # i = 0
91 CPY 1000 1009  # Get N
92 SUBI 1009 1008 # N - i
93 JIF 1008 99    # If i ≥ N, done printing
94 SET 1001 1009  # Base address
95 ADD 1009 1008  # Address of arr[i]
96 SYSCALL PRN 1009 # Print arr[i]
97 ADD 1008 1     # i++
98 JMP 92         # Continue printing
99 SYSCALL HLT    # End sorting thread

# === THREAD 2: LINEAR SEARCH (100-149) ===
100 SET 0 2007    # position = 0
101 SET -1 2008   # result = -1 (not found)
102 CPY 2000 1009 # Get N
103 SUBI 1009 2007 # N - position
104 JIF 2007 130  # If position ≥ N, search complete

105 SET 2002 1009 # Base address of array
106 ADD 1009 2007 # Address of arr[position]
107 CPY 1009 203  # Get arr[position]
108 CPY 2001 204  # Get search key
109 SUBI 203 204  # Compare: arr[position] - key
110 JIF 204 125   # If equal, found it

111 ADD 2007 1    # position++
112 SYSCALL YIELD # Yield to other threads
113 JMP 103       # Continue search

125 CPY 2007 2008 # result = position (found!)
130 SYSCALL PRN 2008 # Print result (-1 or position)
131 SYSCALL HLT   # End search thread

# === THREAD 3: FACTORIAL CALCULATION (150-199) ===
150 CPY 3000 3002 # counter = N
151 SET 1 3001    # result = 1
152 JIF 3002 170  # If counter ≤ 0, done

153 SET 0 1009    # temp = 0 (for multiplication by addition)
154 CPY 3001 203  # current result
155 CPY 3002 204  # current counter
156 JIF 204 165   # If counter ≤ 0, multiplication done
157 ADD 1009 203  # temp += result (multiply by repeated addition)
158 ADD 204 -1    # counter--
159 SYSCALL YIELD # Yield during multiplication
160 JMP 156       # Continue multiplication

165 CPY 1009 3001 # result = temp (new factorial value)
166 ADD 3002 -1   # counter--
167 SYSCALL YIELD # Yield to other threads
168 JMP 152       # Continue factorial calculation

170 SYSCALL PRN 3001 # Print factorial result
171 SYSCALL HLT   # End factorial thread

End Instruction Section 